<script src="./assets/d3.v6.js"></script>

<body></body>

<script type="module">
    import * as math from './math.js';
    import Vector2 from './Vector2.js';
    import QuadraticBezierCurve from './QuadraticBezierCurve.js';

    const r = 80;
    const start = [200, 200];
    const end = [700, 500];
    const points = [start, end];

    const width = 1000;
    const height = 600;

    function renderPoint(selection, x, y, label) {
        selection.append('circle')
            .classed('point', true)
            .attr('cx', x)
            .attr('cy', y)
            .attr('r', 3);
        selection.append('text')
            .text(label)
            .attr('x', x + 10)
            .attr('y', y + 10)
    }

    function renderCure(selection, p0, p1, p2, arrow="#arrow") {
        selection.append('path')
            .classed('curve', true)
            .attr('fill', 'none')
            .attr('stroke', '#000')
            .attr('marker-end', `url(${arrow})`)
            .attr('d', `M ${p0[0]} ${p0[1]} Q ${p1[0]} ${p1[1]} ${p2[0]} ${p2[1]}`);
    }

    // https://blog.csdn.net/gfuugff/article/details/84020509
    function project(p, p1, p2) {
        const v1 = Vector2.fromVectorDifference(p, p1);
        const v2 = Vector2.fromVectorDifference(p2, p1);
        const k = v1.dot(v2) / v2.lengthSq();
        return new Vector2().add(p1).add(v2.multiplyScalar(k));
    }

    const svg = d3.create('svg')
        .attr('width', width)
        .attr('height', height);

    document.body.appendChild(svg.node());

    svg.selectAll('circle.circle')
        .data(points)
        .join('circle')
        .attr('r', r)
        .attr('fill', 'none')
        .attr('stroke', '#000')
        .classed('circle', true)
        .attr('cx', d => d[0])
        .attr('cy', d => d[1]);

    renderPoint(svg, ...start, 'start');
    renderPoint(svg, ...end, 'end');

    const [p1] = math.getMiddlePointOfBezierCurve(...start, ...end, 100);
    renderPoint(svg, ...p1, 'p1');

    const c1 = math.getControlPointOfBezierCurve(start, p1, end);
    renderPoint(svg, ...c1, 'c1');

    renderCure(svg, start, c1, end);

    svg.append('path')
        .attr('stroke', '#000')
        .attr('d', `M${p1[0]} ${p1[1]} L ${end[0]} ${end[1]}`)

    svg.append('path')
        .attr('stroke', '#000')
        .attr('d', `M${c1[0]} ${c1[1]} L ${end[0]} ${end[1]}`)

    svg.append('path')
        .attr('stroke', '#000')
        .attr('d', `M${start[0]} ${start[1]} L ${end[0]} ${end[1]}`)

    const j1 = math.getIntersectPointBetweenCircleAndSegment(...p1, ...end, ...end, r);
    renderPoint(svg, ...j1, 'j1');

    const j1p = project(Vector2.fromArray(j1), Vector2.fromArray(start), Vector2.fromArray(end));
    renderPoint(svg, j1p.x, j1p.y, `j1'`);

    const startv = Vector2.fromArray(start);
    const endv = Vector2.fromArray(end);
    const k = j1p.clone().sub(startv).length() / endv.clone().sub(startv).length();

    const curve = new QuadraticBezierCurve(startv, Vector2.fromArray(c1), endv);
    const p2 = curve.getPoint(k);
    renderPoint(svg, p2.x, p2.y, `p2`);

    const alpha = curve.getDerivative(k);
    const beta = p2.y - alpha * p2.x;
    const j2 = math.getIntersectPointBetweenCircleAndLine3(alpha, beta, ...end, r)[1];
    renderPoint(svg, ...j2, `j2`);


</script>